init enclave 36856896
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 221215.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 425961.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.

[condition_variable] Running condition variable demo.
[condition_variable] Loading Data...
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 629501.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 832241.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1037396.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1243406.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1444939.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1653345.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1860215.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2065523.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 68606326668
destroy enclave 1768216
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

         37,168.10 msec task-clock                       #    1.083 CPUs utilized             
         3,004,207      context-switches                 #   80.828 K/sec                     
         1,369,208      cpu-migrations                   #   36.838 K/sec                     
               656      page-faults                      #   17.650 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

      34.324140433 seconds time elapsed

      28.766210000 seconds user
      10.816159000 seconds sys


init enclave 37242882
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 232827.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 435146.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 639031.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.

[condition_variable] Running condition variable demo.
[condition_variable] Loading Data...
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 840859.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.

[condition_variable] Running condition variable demo.
[condition_variable] Loading Data...
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1052315.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1258843.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1464710.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1670390.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1874645.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2077963.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 67081473220
destroy enclave 1689356
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

         36,311.26 msec task-clock                       #    1.082 CPUs utilized             
         3,002,747      context-switches                 #   82.695 K/sec                     
         1,294,213      cpu-migrations                   #   35.642 K/sec                     
               660      page-faults                      #   18.176 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

      33.562060342 seconds time elapsed

      28.467520000 seconds user
      10.109069000 seconds sys


init enclave 37271468
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 219474.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 421668.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 622579.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 828135.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1030941.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1240741.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1444834.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.

[condition_variable] Running condition variable demo.
[condition_variable] Loading Data...
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1650798.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1854910.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2058454.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 67702432378
destroy enclave 1690316
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

         36,930.18 msec task-clock                       #    1.090 CPUs utilized             
         3,008,094      context-switches                 #   81.454 K/sec                     
         1,347,035      cpu-migrations                   #   36.475 K/sec                     
               655      page-faults                      #   17.736 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

      33.872548999 seconds time elapsed

      28.967860000 seconds user
      10.167150000 seconds sys


init enclave 37213998
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 266206.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 472443.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 679846.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 884538.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1092838.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1297609.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.

[condition_variable] Running condition variable demo.
[condition_variable] Loading Data...
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1495864.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1699256.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1908314.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2113700.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 67524952406
destroy enclave 1705074
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

         36,582.88 msec task-clock                       #    1.083 CPUs utilized             
         3,005,699      context-switches                 #   82.161 K/sec                     
         1,374,271      cpu-migrations                   #   37.566 K/sec                     
               651      page-faults                      #   17.795 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

      33.783642944 seconds time elapsed

      28.923105000 seconds user
       9.886986000 seconds sys


init enclave 37140614
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 222080.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 424023.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 627986.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 828242.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1033356.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1245289.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1452383.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1656576.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1860585.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2078386.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 67353290598
destroy enclave 1698800
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

         36,385.03 msec task-clock                       #    1.080 CPUs utilized             
         2,999,570      context-switches                 #   82.440 K/sec                     
         1,359,941      cpu-migrations                   #   37.376 K/sec                     
               656      page-faults                      #   18.029 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

      33.697814705 seconds time elapsed

      28.744313000 seconds user
       9.985475000 seconds sys


init enclave 37068610
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 229555.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 433409.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 641030.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 843961.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1049373.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1254343.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1459205.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1663403.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1868672.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2077540.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 66994327730
destroy enclave 1727298
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

         36,347.18 msec task-clock                       #    1.084 CPUs utilized             
         3,000,714      context-switches                 #   82.557 K/sec                     
         1,241,835      cpu-migrations                   #   34.166 K/sec                     
               663      page-faults                      #   18.241 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

      33.518320741 seconds time elapsed

      28.736447000 seconds user
       9.785110000 seconds sys


init enclave 36703046
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 231135.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 433527.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 639896.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 846777.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1050955.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1255767.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1457510.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1660839.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1865530.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.

[condition_variable] Running condition variable demo.
[condition_variable] Loading Data...
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2069913.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 67808044474
destroy enclave 1763338
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

         36,727.17 msec task-clock                       #    1.083 CPUs utilized             
         3,010,614      context-switches                 #   81.972 K/sec                     
         1,267,914      cpu-migrations                   #   34.523 K/sec                     
               660      page-faults                      #   17.970 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

      33.925045593 seconds time elapsed

      29.110146000 seconds user
       9.818844000 seconds sys


init enclave 36777554
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 234345.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 436564.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 642754.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 845882.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1048644.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1252815.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1453969.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1656855.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.

[condition_variable] Running condition variable demo.
[condition_variable] Loading Data...
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1863043.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2066695.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 66247472478
destroy enclave 1693154
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

         36,015.73 msec task-clock                       #    1.087 CPUs utilized             
         3,003,169      context-switches                 #   83.385 K/sec                     
         1,193,522      cpu-migrations                   #   33.139 K/sec                     
               659      page-faults                      #   18.298 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

      33.144735765 seconds time elapsed

      28.490959000 seconds user
       9.650108000 seconds sys


init enclave 36756842
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 208150.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 412257.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 616660.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 822411.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1025361.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1226316.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1432046.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1638615.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1841288.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2052183.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 66730485814
destroy enclave 1724450
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

         36,123.62 msec task-clock                       #    1.082 CPUs utilized             
         3,005,616      context-switches                 #   83.204 K/sec                     
         1,284,693      cpu-migrations                   #   35.564 K/sec                     
               658      page-faults                      #   18.215 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

      33.386344780 seconds time elapsed

      28.267508000 seconds user
      10.059871000 seconds sys


init enclave 36958368
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 215992.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 422896.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 626238.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 832371.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1034227.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1234227.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1439807.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1641086.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1846811.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.

[condition_variable] Running condition variable demo.
[condition_variable] Loading Data...
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2052385.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 66885038160
destroy enclave 1747066
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

         36,205.70 msec task-clock                       #    1.082 CPUs utilized             
         3,005,026      context-switches                 #   82.999 K/sec                     
         1,320,968      cpu-migrations                   #   36.485 K/sec                     
               650      page-faults                      #   17.953 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

      33.463686622 seconds time elapsed

      28.891969000 seconds user
       9.663318000 seconds sys


init enclave 37135530
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 228091.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 430386.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 638365.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 843129.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1042302.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1248780.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.

[condition_variable] Running condition variable demo.
[condition_variable] Loading Data...
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1452310.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1652310.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1862465.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2064473.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.

[condition_variable] Loading Data...
[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 68310599174
destroy enclave 1699926
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

         36,734.17 msec task-clock                       #    1.075 CPUs utilized             
         3,006,489      context-switches                 #   81.844 K/sec                     
         1,425,335      cpu-migrations                   #   38.801 K/sec                     
               660      page-faults                      #   17.967 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

      34.176521998 seconds time elapsed

      29.220995000 seconds user
       9.871074000 seconds sys


