init enclave 80559812
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 8893772336
destroy enclave 1940144
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

          4,488.68 msec task-clock                       #    1.000 CPUs utilized             
           322,042      context-switches                 #   71.745 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               663      page-faults                      #  147.705 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       4.489799642 seconds time elapsed

       4.071198000 seconds user
       0.384010000 seconds sys


init enclave 80449018
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 10167114618
destroy enclave 1916246
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

          5,125.14 msec task-clock                       #    1.000 CPUs utilized             
           364,469      context-switches                 #   71.114 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               659      page-faults                      #  128.582 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       5.126054257 seconds time elapsed

       4.648786000 seconds user
       0.439726000 seconds sys


init enclave 81400840
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 3255066778
destroy enclave 1915330
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

          1,669.88 msec task-clock                       #    1.000 CPUs utilized             
           113,086      context-switches                 #   67.721 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               654      page-faults                      #  391.645 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       1.670452676 seconds time elapsed

       1.454225000 seconds user
       0.203469000 seconds sys


init enclave 80310196
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 20730181456
destroy enclave 1925950
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

         10,406.32 msec task-clock                       #    1.000 CPUs utilized             
           765,366      context-switches                 #   73.548 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               668      page-faults                      #   64.192 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

      10.407167255 seconds time elapsed

       9.468804000 seconds user
       0.862657000 seconds sys


init enclave 80094352
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[condition_variable] Loading Data...
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 7061402966
destroy enclave 1921306
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

          3,572.23 msec task-clock                       #    1.000 CPUs utilized             
           251,689      context-switches                 #   70.457 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               660      page-faults                      #  184.758 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       3.572908030 seconds time elapsed

       3.191731000 seconds user
       0.354271000 seconds sys


init enclave 80329376
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 6932578604
destroy enclave 1924516
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

          3,507.90 msec task-clock                       #    1.000 CPUs utilized             
           247,939      context-switches                 #   70.680 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               662      page-faults                      #  188.717 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       3.508564654 seconds time elapsed

       3.141981000 seconds user
       0.340456000 seconds sys


init enclave 80906310
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 5619574270
destroy enclave 1912970
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

          2,846.96 msec task-clock                       #    0.998 CPUs utilized             
           192,238      context-switches                 #   67.524 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               662      page-faults                      #  232.528 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       2.852358805 seconds time elapsed

       2.542571000 seconds user
       0.283807000 seconds sys


init enclave 80792618
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 7807525874
destroy enclave 1907560
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

          3,938.26 msec task-clock                       #    0.998 CPUs utilized             
           285,860      context-switches                 #   72.585 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               658      page-faults                      #  167.079 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       3.946272506 seconds time elapsed

       3.507468000 seconds user
       0.402038000 seconds sys


init enclave 80911552
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 8886181022
destroy enclave 1914086
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

          4,484.29 msec task-clock                       #    1.000 CPUs utilized             
           321,871      context-switches                 #   71.777 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               663      page-faults                      #  147.849 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       4.485634741 seconds time elapsed

       4.121077000 seconds user
       0.330558000 seconds sys


init enclave 80761494
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 19691987886
destroy enclave 1914780
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

          9,886.92 msec task-clock                       #    1.000 CPUs utilized             
           729,437      context-switches                 #   73.778 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               663      page-faults                      #   67.058 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       9.888221079 seconds time elapsed

       9.062426000 seconds user
       0.753376000 seconds sys


