init enclave 80711874
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 9628191918
destroy enclave 2047278
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

          4,856.06 msec task-clock                       #    1.000 CPUs utilized             
           320,466      context-switches                 #   65.993 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               659      page-faults                      #  135.707 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       4.856871110 seconds time elapsed

       4.422474000 seconds user
       0.402378000 seconds sys


init enclave 81135662
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 6283834264
destroy enclave 2000524
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

          3,184.09 msec task-clock                       #    1.000 CPUs utilized             
           211,397      context-switches                 #   66.392 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               659      page-faults                      #  206.967 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       3.184867037 seconds time elapsed

       2.910376000 seconds user
       0.253252000 seconds sys


init enclave 80718538
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 6650623236
destroy enclave 2008112
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

          3,366.42 msec task-clock                       #    1.000 CPUs utilized             
           225,268      context-switches                 #   66.916 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               663      page-faults                      #  196.945 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       3.368054943 seconds time elapsed

       3.044389000 seconds user
       0.301012000 seconds sys


init enclave 79176668
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 3709794196
destroy enclave 2069316
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

          1,888.33 msec task-clock                       #    0.996 CPUs utilized             
           119,737      context-switches                 #   63.409 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               659      page-faults                      #  348.986 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       1.896747579 seconds time elapsed

       1.719953000 seconds user
       0.155982000 seconds sys


init enclave 80681498
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 5405724876
destroy enclave 2004884
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

          2,744.64 msec task-clock                       #    1.000 CPUs utilized             
           177,322      context-switches                 #   64.607 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               658      page-faults                      #  239.740 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       2.745519412 seconds time elapsed

       2.462021000 seconds user
       0.252343000 seconds sys


init enclave 79617596
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 14922896670
destroy enclave 2062514
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

          7,502.52 msec task-clock                       #    1.000 CPUs utilized             
           434,874      context-switches                 #   57.964 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               661      page-faults                      #   88.104 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       7.503682471 seconds time elapsed

       6.825622000 seconds user
       0.635961000 seconds sys


init enclave 81408120
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 218091870
destroy enclave 1977334
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

            151.58 msec task-clock                       #    0.996 CPUs utilized             
               199      context-switches                 #    1.313 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               660      page-faults                      #    4.354 K/sec                     
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       0.152129765 seconds time elapsed

       0.112101000 seconds user
       0.038683000 seconds sys


init enclave 81039404
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 7958135008
destroy enclave 2072608
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

          4,021.06 msec task-clock                       #    1.000 CPUs utilized             
           264,651      context-switches                 #   65.816 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               659      page-faults                      #  163.887 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       4.022019242 seconds time elapsed

       3.632028000 seconds user
       0.363866000 seconds sys


init enclave 80405828
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 430446654
destroy enclave 1978492
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

            257.22 msec task-clock                       #    0.998 CPUs utilized             
             7,984      context-switches                 #   31.040 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               660      page-faults                      #    2.566 K/sec                     
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       0.257758386 seconds time elapsed

       0.200600000 seconds user
       0.054600000 seconds sys


init enclave 80177792
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 543135808
destroy enclave 1999586
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

            313.44 msec task-clock                       #    0.998 CPUs utilized             
            12,134      context-switches                 #   38.713 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               661      page-faults                      #    2.109 K/sec                     
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       0.314044845 seconds time elapsed

       0.254134000 seconds user
       0.057561000 seconds sys


init enclave 78900208
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 300000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 600000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 900000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1200000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1500000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 1800000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2100000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2400000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 2700000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
[Lambdas] Initial array using lambdas: { 0 1 2 3 4 5 6 7 8 9 10 }.
[Lambdas] First odd element in the array is 1. 
[Lambdas] Number of even elements in the array is 6.
[Lambdas] Array after sort: { 10 9 8 7 6 5 4 3 2 1 0 }. 

[auto] Type of a is int. typeid = i.
[auto] Type of b1 is const double. typeid = d.
[auto] Type of b2 is const double*. typeid = PKd.
[auto] Type of c is int. typeid = i.
[auto] Type of d is int*. typeid = Pi.
[auto] Type of lambda is [] {}. typeid = *Z15ecall_auto_demoEUlvE_.
[auto] Type of func is void(__cdecl*)(void). typeid = PFvvE.
[auto] Function sample_func_auto_demo is called. 

[decltype] Type of b is int. typeid = i.
[decltype] Type of sum is double. typeid = d.

[range_based_for_loops] Using range based for loops to print the content of an array: { a b c d }. 
[range_based_for_loops] Using range based for loops to print the content of an vector: { a b c d }.

[delegating constructors] Called from DemoDelegatingConstructors(int a, int b, int c).
[delegating constructors] Called from DemoDelegatingConstructors(int a, int b). 
[delegating constructors] Called from DemoDelegatingConstructors(int a). 

[std_function] calling sample_std_function1
[std_function] calling a lambda function

[cxx11_algorithms] All elements in  { 0 1 2  3 4 5 } are even is  false. 
[cxx11_algorithms] Some elements in  { 0 1 2 3 4 5 } are even is  true. 
[cxx11_algorithms] None elements in  { 0 1 2 3 4 5 } are even is  false. 

[variadic_templates] The sum  of paramters (1, 2, 3, 4, 5) is 15. 

[sfinae] Second candidate for substitution is matched.

[initializer_list] Using initializer list in the constructor. 
[initializer_list] The elements of the vector are: 10 9 8 7 6 5 4 3 2 1.

[rvalue] DemoBuffer a(100).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] DemoBuffer foobar(100). 
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called constructor : DemoBuffer(int size).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).
[rvalue] DemoBuffer b(a).
[rvalue] Called copy constructor : DemoBuffer(const DemoBuffer & rhs).
[rvalue] DemoBuffer c(std::move(a)).
[rvalue] Called move constructor : DemoBuffer(DemoBuffer && rhs).

[nullptr] called void nullptr_overload_candidate(int i).
[nullptr] called void nullptr_overload_candidate(int* ptr).
[nullptr] Function g called
[nullptr] Function g called
[nullptr] Function g called

[enum class] brown - int = 1
[enum class] red - int = 32
[enum class] green - int = 30

[new_container_classes] unordered_set { 0, 1, 2, 3, 4, 5} has value 3.
[new_container_classes] multiset_set { 0, 1, 2, 3, 3, 3}  has 3 elements with value 3.
[new_container_classes] unordered_map elements: {[E 3] [D 5] [C 7] [B 8] [A 10] }.
[new_container_classes] unordered_multimap elements: {[E 5] [E 3] [E 1] [B 8] [B 7] [A 10] }.

[tuple] show first  element in TupleSample: <First element of TupleSample>. 
[tuple] show second element in TupleSample: 1. 
[tuple] show third  element in TupleSample: 7.900000. 

[smart_ptr] In construct of object demo_smart_ptr  using smart_ptr.. 
[smart_ptr] shared_ptr reference count = 1.  
[smart_ptr] shared_ptr reference count = 2 incresead after creating another shared pointer.
[smart_ptr] shared_ptr reference count = 1 decresead after calling releasing ownership. 
[smart_ptr] In construct of object demo_smart_ptr  using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using unique_ptr. 
[smart_ptr] In deconstructor of object demo_smart_ptr using smart_ptr.. 
[atomic] Atomic types, objects and functions demo.
[atomic_store] Defining an atomic_char object with an initial value of 5.
[atomic_store] The current value stored in the atomic object is: 5
[atomic_store] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_store_explicit] Defining an atomic_short object with an initial value of 5.
[atomic_store_explicit] The current value stored in the atomic object is: 5.
[atomic_store_explicit] Replacing the value of the atomic object with a non-atomic value of 3.
[atomic_store] The new value of the atomic object is: 3.

[atomic_load] Defining an atomic_int object with an initial value of 4.
[atomic_load] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load] The obtained value is 4.

[atomic_load_explicit] Defining an atomic_int object with an initial value of 2.
[atomic_load_explicit] Obtaining the value of the atomic object and saving it in a int variable.
[atomic_load_explicit] The obtained value is 2.

[atomic_fetch_add] Defining an atomic_int object with an initial value of 7.
[atomic_fetch_add] The current value stored in the atomic object is: 7.
[atomic_fetch_add] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add] The new value of the atomic object is: 15.

[atomic_fetch_add_explicit] Defining an atomic_uint object with an initial value of 7.
[atomic_fetch_add_explicit] The current value stored in the atomic object is: 7.
[atomic_fetch_add_explicit] Adding a non-atomic value of 8 to the atomic object.
[atomic_fetch_add_explicit] The new value of the atomic object is: 15.

[atomic_fetch_sub] Defining an atomic_long object with an initial value of 20.
[atomic_fetch_sub] The current value stored in the atomic object is: 20.
[atomic_fetch_sub] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub] The new value of the atomic object is: 12.

[atomic_fetch_sub_explicit] Defining an atomic_llong object with an initial value of 20.
[atomic_fetch_sub_explicit] The current value stored in the atomic object is: 20.
[atomic_fetch_sub_explicit] Substracting a non-atomic value of 8 from the value of the atomic object.
[atomic_fetch_sub_explicit] The new value of the atomic object is: 12.

[mutex] Incrementing values in three threads without mutex protection, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[mutex] Mutex protection when incrementing a value in 3 threads, using a 100000 times loop. 
[mutex]Expected value is 300000. The final value is 3000000.
[condition_variable] Loading Data...

[condition_variable] Running condition variable demo.
[condition_variable] Waiting for the data to be loaded in the other thread.
[condition_variable] Processing the loaded data.
[condition_variable] Done.
ecall enclave 6323517354
destroy enclave 1992050
Info: Cxx11DemoEnclave successfully returned.

 Performance counter stats for './app':

          3,202.58 msec task-clock                       #    1.000 CPUs utilized             
           211,368      context-switches                 #   65.999 K/sec                     
                 0      cpu-migrations                   #    0.000 /sec                      
               659      page-faults                      #  205.772 /sec                      
   <not supported>      cycles                                                                
   <not supported>      instructions                                                          
   <not supported>      branches                                                              
   <not supported>      branch-misses                                                         

       3.203458724 seconds time elapsed

       2.905030000 seconds user
       0.277256000 seconds sys


